Author: Jonathan Dawson
Date: December 6, 2019

Solutelia Boundary Programming Problem

The problem as stated is difficult for me to understand due to its grammar and brevity.  I presume that the number "1" forms a boundary which encloses a 2-dimensional area completely.  I also presume that all locations within that entire area, including the "1"s, should return a "1" while all the other locations should return a "0".  I also presume that the boundary must be fully enclosed within a border of "0"s so that it does not fall outside of the given map, making it impossible to discern inside from outside.

I would use a breadth-first search to solve this type of graph problem efficiently, such as A* or flood-fill search.  I present only the flood-fill algorithm below due to its simplicity and ease of implementation in many languages.

First, using a breadth-first queue-based iteration search, enqueue the location of all border "0"s.  Then, as you dequeue each location, enqueue all adjacent "0" locations that are reachable by moving up, down, left or right from the current location.  Then, continue by expanding the next queued location until the queue is empty.  Every "0" reached would be changed to "2" so that it was never searched again.  This would fill the entire surrounding area with "2"s.  The remaining "1"s and "0"s would be considered inside the enclosed area while the "2"s would be considered outside the area.  Upon inquiry, the method would return "1" for any location containing either a "1" or a "0", and would return "0" for any location containing a "2".  The search would complete in O(N) time complexity.
